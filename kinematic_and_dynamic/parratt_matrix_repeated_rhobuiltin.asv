function output = parratt_matrix_repeated_rhobuiltin(Q,lambda,stack,control,instrument)

output.trans      = [];
output.absorption = [];
output.I          = [];
output.refl       = [];


% Assuming the z axis of the unit cell is aligned with Q
Z = (1:118);
Zt = {'H','He','Li','Be','B','C','N','O','F','Ne','Na','Mg','Al','Si','P','S','Cl','Ar','K','Ca','Sc','Ti','V','Cr',...
  'Mn','Fe','Co','Ni','Cu','Zn','Ga','Ge','As','Se','Br','Kr','Rb','Sr','Y','Zr','Nb','Mo','Tc','Ru','Rh','Pd','Ag','Cd',...
  'In','Sn','Sb','Te','I','Xe','Cs','Ba','La','Ce','Pr','Nd','Pm','Sm','Eu','Gd','Tb','Dy','Ho','Er','Tm','Yb',...
  'Lu','Hf','Ta','W','Re','Os','Ir','Pt','Au','Hg','Tl','Pb','Bi','Po','At','Rn','Fr','Ra',...
  'Ac','Th','Pa','U','Np','Pu','Am','Cm','Bk','Cf','Es','Fm','Md','No','Lr','Rf','Db','Sg','Bh','Hs','Mt','Ds','Rg','Cn','Nh','Fl','Mc','Lv','Ts','Og'};

% Read poscar and generate lattice vectors, area and volume.
% Generate strain profiles

Q0 = (-control.maxQ0:control.stepQ0:control.maxQ0)';
strain = cell(length(stack),1);
for o = 1:length(stack)

    layer   = stack{o};
    N       = round(layer.N);
    if isempty(stack{o}.pre_calc_f)
      calculate_from_scratch = true;
      pre_calc_f = [];
      [type,type_nr,r,a1,a2,a3] = read_poscar(stack{o}.filename);
      pre_calc_f(1).a1 = a1;
      pre_calc_f(1).a2 = a2;
      pre_calc_f(1).a3 = a3;
      pre_calc_f(1).type = type;
      pre_calc_f(1).type_nr = type_nr;
      pre_calc_f(1).r = r;
    else
      calculate_from_scratch = false;
      pre_calc_f = stack{o}.pre_calc_f;
    end

    as = sqrt(stack{o}.area_scale);

   switch stack{o}.direction
     case 1
       scaling = pre_calc_f(1).a1*stack{o}.scale;
       area(o)    = abs(norm(cross(pre_calc_f(1).a2*as,pre_calc_f(1).a3*as)));
       v_uc    = abs(dot(scaling,cross(pre_calc_f(1).a2*as,pre_calc_f(1).a3*as)));
     case 2
       scaling = pre_calc_f(1).a2*stack{o}.scale;
       area(o)    = abs(norm(cross(pre_calc_f(1).a1*as,pre_calc_f(1).a3*as)));
       v_uc    = abs(dot(scaling,cross(pre_calc_f(1).a1*as,pre_calc_f(1).a3*as)));
     case 3
       scaling = pre_calc_f(1).a3*stack{o}.scale;
       area(o)    = abs(norm(cross(pre_calc_f(1).a1*as,pre_calc_f(1).a2*as)));
       v_uc    = abs(dot(scaling,cross(pre_calc_f(1).a1*as,pre_calc_f(1).a2*as)));
   end

    lat_par(o) = norm(scaling);
    z_s = zeros(size(pre_calc_f(1).r,1),1);
    for l = 1:size(pre_calc_f(1).r,1)
      z_s(l) = pre_calc_f(1).r(l,:)*scaling';
    end
    z_ss{o} = z_s;
    r_ss{o} = pre_calc_f(1).r;
    


    k = 0;
    l = 0;
    f = zeros(length(Q0),length(z_ss{o}));

    for i = 1:size(pre_calc_f(1).type,1) %
      if ~isempty(pre_calc_f(1).type{i})
        k = k + 1;
        cur_Z = Z(strcmp(Zt,pre_calc_f(1).type{i}));
        if calculate_from_scratch
          [g , ~, ] = Form_factors(Q0(:),  Read_form_factor_coefficients(cur_Z,lambda), 100/100);
          B = DB_prefactor(cur_Z);
          pre_calc_f(k).f = g.*exp(-B*(Q0/4/pi).^2);
        end
        for j = 1:pre_calc_f(1).type_nr(k)
          l = l + 1;
                
          f(:,l)  = pre_calc_f(k).f;
          coeffs(l) =  Read_form_factor_coefficients(cur_Z,lambda);

        end
      end
    end
    ff{o} = f;

    full_stack = false;
    % Totthick when doing the repeated uc trick
    if o == 1
      if full_stack
        totthick = lat_par(o)*N;
        last_atom_z = lat_par(1)*(N-1)+max(z_ss{1});
        strain{o} = last_atom_z;
      else
        totthick = lat_par(o)*3;
        last_atom_z = lat_par(1)*(3-1)+max(z_ss{1});
        strain{o} = last_atom_z;
      end
    end
    if o > 1
      if o > 2
        last_atom_z = strain{o-1}(end);
      end

      startz = last_atom_z + stack{o}.dinterface;
      if stack{o}.roughness
        sorted_idx = {};
        strained_position = {};
        sigma  = stack{o}.sigma;
        nvector = max(1,round(N-3*sigma)):1:max(1,round(N+3*sigma));

        B   = zeros(size(nvector));

        if sigma == 0
          A = 1;
        else
          A = 1/(sqrt(2*pi)*sigma);
        end

        for NN = nvector
          if sigma ==0
            B(NN) = 1;
          else
            B(NN)         = A*exp(-(NN-N)^2/(2*sigma^2));
          end
        end
        for m = nvector
          [strained_position{m},sorted_idx{m}] = generate_strain(z_ss{o},lat_par,m,o,startz,stack);
        end
      else
        [strained_position,sorted_idx] = generate_strain(z_ss{o},lat_par,N,o,startz,stack);
      end

      strain{o} = strained_position;
      sorted{o} = sorted_idx;
    end
end

 if stack{o}.roughness
   s = strain{end};
   for lll = 1:length(s)
 
    tt(lll) = max([max(s{lll}),0]);
   end
   totthick = max(tt);

else
  totthick = max(strain{end});
 end
 tic
disp('Generating density...')
for o = 1:length(stack)
    N = round(stack{o}.N);
    if o == 1 % substrate
      slices = control.slices;
      dz     = lat_par(o)/slices; % A
      vacuum_slices = round(control.vacuum_thick/dz);
      vacuum_thick  = dz*vacuum_slices;

      z = -vacuum_thick:dz:totthick+vacuum_thick;
      rho_e = zeros(size(z));

      if ~full_stack
        for l = 1:3 
            for s = 1:length(z_ss{o})
                idx = z >= z_ss{o}(s) + lat_par(o)*(l-1) - 1*lat_par(o) & z <= z_ss{o}(s) + lat_par(o)*(l-1) + 1*lat_par(o);

                rho_e(idx) = rho_e(idx) + 1/area(o)*trapz(Q0,ff{o}(:,s).*exp(1i*Q0*(z(idx) - z_ss{o}(s) - lat_par(o)*(l-1))));
           end
        end
        last_atom_z = lat_par(o)*(3-1)+max(z_ss{o});
        substrate_end_z = last_atom_z;
      else
        %for calculating the full stack
        for l = 1:N  
          for s = 1:length(z_ss{o})
            idx = z >= z_ss{o}(s) + lat_par(o)*(l-1) - 1*lat_par(o) & z <= z_ss{o}(s) + lat_par(o)*(l-1) + 1*lat_par(o);
            rho_e(idx) = rho_e(idx) + 1/area(o)*trapz(Q0,ff{o}(:,s).*exp(1i*Q0*(z(idx) - z_ss{o}(s) - lat_par(o)*(l-1))));
          end
        end
        last_atom_z = lat_par(o)*(N-1)+max(z_ss{o});
        substrate_end_z = lat_atom_z;
      end

        start_idx = slices;
        z_0   = z(1:vacuum_slices+start_idx);
        z_1   = z(vacuum_slices+start_idx:vacuum_slices+start_idx*2);
        z_2   = z(vacuum_slices+start_idx*2:vacuum_slices+start_idx*3); % was 5
        rho_0 = rho_e(1:vacuum_slices + start_idx);
        rho_1 = rho_e(vacuum_slices + start_idx:vacuum_slices+start_idx*2);
        rho_2 = rho_e(vacuum_slices + start_idx*2:vacuum_slices + start_idx*3);
 
    else % film

      if stack{o}.roughness
        startz = last_atom_z + stack{o}.dinterface;

        sigma  = stack{o}.sigma;
        nvector = max(1,round(N-3*sigma)):1:max(1,round(N+3*sigma));

        B   = zeros(size(nvector));
        
        if sigma == 0
          A = 1;
        else
          A = 1/(sqrt(2*pi)*sigma);
        end
        
        

        for NN = nvector

          % including roughness
          if sigma ==0
            B(NN) = 1;
          else
            B(NN)         = A*exp(-(NN-N)^2/(2*sigma^2));
          end
        end

        % Assuming rho_e is large enough to cover all the unit cells
        rho_e_rough = cell(length(nvector),1);
        for m = nvector
         rho_e_rough{m} = generate_density(z_ss,rho_e,sorted_idx{m},o,m,lat_par,area,Q0,ff,z,strained_position{m});
        end

      else % no roughness
        % We put the next unit cell ontop of the last atom in the previous unit cell plus some interface distance.
        % Beware if none of the coordinates in the new unit cell are zero, you get an additional distance.
        % rho_e = generate_density(z_ss,rho_e,sorted{o},o,N,lat_par,area,Q0,ff,z,strain{o});
         ll = 1;
         sorted_idx = sorted{o};
         for l = 1:N
           for s = 1:length(z_ss{o})
             pos_z                   = strain{o}(ll);
             idx = z >= pos_z - 1*lat_par(o) & z <=  pos_z + 1*lat_par(o);

             rho_e(idx) = rho_e(idx) + 1/area(o)*trapz(Q0,ff{o}(:,sorted_idx(s)).*exp(1i*Q0*(z(idx) - pos_z)));
             ll = ll + 1;
           end
         end
        last_atom_z = startz + lat_par(o)*(N-1) + max(z_ss{o});

      end
    end

end
disp('done')
toc

% We have the density vs z. Now lets propagate

if ~full_stack && ~control.dotransmission
  rho_0r = rho_0(end:-1:1);
  rho_1r = rho_1(end:-1:1);
  rho_rest = rho_e(vacuum_slices+start_idx*2:end);
  
  if control.plot_density
    figure(2)
    clf
    plot(z_0,real(rho_0),'-r')
    hold on;
    plot(z_1,real(rho_1),'-k')
    plot(z_2,real(rho_2),'-b')
    z_rest   = z(vacuum_slices+start_idx*2:end);

    plot(z_rest,real(rho_rest),'-m');
  end
  disp('Propagating...')
  tic
  if stack{o}.roughness
    substrate_end = vacuum_slices+start_idx*2;
    if control.pol == 0 || control.pol == 1
      output.refl   = propagate_vectorized_chunks_roughness(Q,lambda,rho_0r,rho_1r,round(stack{1}.N),rho_e_rough,dz,substrate_end,nvector,B,control.pol);
    elseif control.pol == 2
      refl_p   = propagate_vectorized_chunks_roughness(Q,lambda,rho_0r,rho_1r,round(stack{1}.N),rho_e_rough,dz,substrate_end,nvector,B,0);
      refl_s   = propagate_vectorized_chunks_roughness(Q,lambda,rho_0r,rho_1r,round(stack{1}.N),rho_e_rough,dz,substrate_end,nvector,B,1);

      output.refl = (refl_s + cosd(instrument.theta_m*2)^2.*refl_p)./(1 + cosd(instrument.theta_m*2).^2);
    end
  else % no roughness

    rho_restr = rho_rest(end:-1:1);

    if control.pol == 0 || control.pol == 1
      output.refl = propagate_vectorized_chunks(Q,lambda,rho_0r,rho_1r,round(stack{1}.N),rho_restr,dz,stack{o}.sigma,control.pol);

    elseif control.pol == 2
      refl_p = propagate_vectorized_chunks(Q,lambda,rho_0r,rho_1r,round(stack{1}.N),rho_restr,dz,stack{o}.sigma,0);
      refl_s = propagate_vectorized_chunks(Q,lambda,rho_0r,rho_1r,round(stack{1}.N),rho_restr,dz,stack{o}.sigma,1);

      % Parratt's formalism includes the cosd(theta*2)^2 from the sample
      % Here we correct the pi polarization for the polarization picked up by the monochromator
      % and then we divide by the intensity just before the sample, which has polarization 1+cosd(theta_m*2)^2
      output.refl = (refl_s + cosd(instrument.theta_m*2)^2.*refl_p)./(1 + cosd(instrument.theta_m*2).^2);
    end
  end
toc
disp('done')
else % for debugging

m    = length(Q);
k0   = 2*pi/lambda;
refl  = zeros(size(Q));
trans = refl;

if full_stack

  parfor k = 1:m

    Mcell     = eye(2,2);
    Mcell = do_matrix_propagation_optimzed(Q(k),lambda,k0,Mcell,rho_e(end:-1:1),dz);
    refl(k)       = Mcell(2,1)/Mcell(1,1);
  end
end

if control.dotransmission % experimental, use at own risk
  rho_0r    = rho_0(end:-1:1);
  rho_1r    = rho_1(end:-1:1);
  rho_rest = rho_e(vacuum_slices+start_idx*2:end);
  z_rest   = z(vacuum_slices+start_idx*2:end);

  rho_restr = rho_rest(end:-1:1);
  z_restr   = z_rest(end:-1:1);
 
  parfor k = 1:m

    Mcell     = eye(2,2);
    Mcell_inv = eye(2,2);
    [Mcell,Mcell_inv]  = do_matrix_propagation_optimzed_incl_trans(Q(k),lambda,k0,Mcell,rho_0r,dz,Mcell_inv);

    % Mcell_inv is Mcell multiplied in the reverse order

    [Mcell1,~] = do_matrix_propagation_optimzed_incl_trans(Q(k),lambda,k0,eye(2,2),rho_1r,dz,eye(2,2));
    [M_repeated,M_repeated_inv] = fastMatrixExponentiation(Mcell1,stack{1}.N-2);

    Mcell      = M_repeated*Mcell;
    Mcell_inv  = M_repeated_inv*Mcell_inv;
    [Mcell,Mcell_inv]  = do_matrix_propagation_optimzed_incl_trans(Q(k),lambda,k0,Mcell,rho_restr,dz,Mcell_inv); %,z_rest(end:-1:1));


    ET = Mcell(1,1)*1 + Mcell(1,2)*0;
    ER = Mcell(2,1)*1 + Mcell(2,2)*0;

    [Mcell,ER,ET]  = do_matrix_propagation_optimzed_w_efield(Q(k),lambda,k0,Mcell,rho_restr,dz,ER,ET);

    idx = find(z_restr>=last_atom_z);
    ERR = ER/ER(idx(end));
    ETT = ET/ER(idx(end));

      refl(k)       = Mcell(2,1)/Mcell(1,1);
      trans(k)      = 1/Mcell_inv(1,1);
      I(k,:)        = abs( ERR + ETT ).^2;
  end
end

output.refl  = abs(refl).^2;
output.trans = abs(trans).^2;
output.absorption = 1 - output.refl - output.trans;
output.I          = I;
 
end
%toc
end

function Mcell = do_matrix_propagation(Mcell,kz,dz)

      for j = length(kz):-1:2
          denom = kz(j-1) + kz(j);
          r     = (kz(j-1) - kz(j))/denom;
          t     = 2*kz(j-1)        /denom;

          R   = [1 r; r 1]/t; % j = N+1
          phi = [exp(1i*kz(j)*dz/2) 0; 0 exp(-1i*kz(j)*dz/2)]; % j = N

          Mcell = R*phi*Mcell;
      end
end


function [Mcell] = do_matrix_propagation_optimzed(Q, lambda, k0, Mcell, rho_e, dz) %,z)
    % Constants
    re = 2.814042735053330e-05;
    factor      = 8 * k0^2 * lambda^2 / (2 * pi);
    
    % Precompute layer properties
    sld   = rho_e * re / (2 * pi ); 
    delta = factor * real(sld);
    beta  = 1i*factor * imag(sld);
    
     

    % Compute kz and kz of adjacent layers
    kz_all     = sqrt(Q.^2 - delta + beta);  % Vectorized kz
    kz_shifted = circshift(kz_all, 1);   % Shifted kz for previous layer
    
    denom = 1./(kz_shifted + kz_all);
    r     = (kz_shifted-kz_all).*denom;
    t     = 2*kz_shifted.*denom;

    exp_pos  = exp(1i * kz_all * dz / 2);
    
    invtp     = exp_pos./t;
    invtm     = 1./(t.*exp_pos);

    A(1,1,:) = invtp;
    A(1,2,:) = invtm.*r;
    A(2,1,:) = invtp.*r;
    A(2,2,:) = invtm;

   
   B = eye(2,2);
  

   for j = length(rho_e):-1:2
     B = A(:,:,j)*B;
   end

   Mcell = B*Mcell;
end

function [Mcell,ER,ET] = do_matrix_propagation_optimzed_w_efield(Q, lambda, k0, Mcell, rho_e, dz, ERR, ETT) %,z)
    % Constants
    re = 2.814042735053330e-05;
    factor      = 8 * k0^2 * lambda^2 / (2 * pi);
    
    % Precompute layer properties
    sld   = rho_e * re / (2 * pi ); 
    delta = factor * real(sld);
    beta  = 1i*factor * imag(sld);
    
     

    % Compute kz and kz of adjacent layers
    kz_all     = sqrt(Q.^2 - delta + beta);  % Vectorized kz
    kz_shifted = circshift(kz_all, 1);   % Shifted kz for previous layer
    
    denom = 1./(kz_shifted + kz_all);
    r     = (kz_shifted-kz_all).*denom;
    t     = 2*kz_shifted.*denom;

    exp_pos  = exp(1i * kz_all * dz / 2);
    
    invtp     = exp_pos./t;
    invtm     = 1./(t.*exp_pos);

    A(1,1,:) = invtp;
    A(1,2,:) = invtm.*r;
    A(2,1,:) = invtp.*r;
    A(2,2,:) = invtm;

   
   B = eye(2,2);
  
   ER = zeros(1,length(rho_e));
   ET = ER;
   ER = [ER ERR];
   ET = [ET ETT];
   for j = length(rho_e):-1:2
     B    = A(:,:,j)*B;
     ET(j) = A(1,1,j)*ET(j+1) + A(1,2,j)*ER(j+1);
     ER(j) = A(2,1,j)*ET(j+1) + A(2,2,j)*ER(j+1);
   end

   Mcell = B*Mcell;
end

function [Mcell,Mcell_inv] = do_matrix_propagation_optimzed_incl_trans(Q, lambda, k0, Mcell, rho_e, dz, Mcell_inv) %,z)
    % Constants
    re = 2.814042735053330e-05;
    factor      = 8 * k0^2 * lambda^2 / (2 * pi);
    
    % Precompute layer properties
    sld   = rho_e * re / (2 * pi ); 
    delta = factor * real(sld);
    beta  = 1i*factor * imag(sld);
    
     

    % Compute kz and kz of adjacent layers
    kz_all     = sqrt(Q.^2 - delta + beta);  % Vectorized kz
    kz_shifted = circshift(kz_all, 1);   % Shifted kz for previous layer
    
    denom = 1./(kz_shifted + kz_all);
    r     = (kz_shifted-kz_all).*denom;
    t     = 2*kz_shifted.*denom;

    exp_pos  = exp(1i * kz_all * dz / 2);
    
    invtp     = exp_pos./t;
    invtm     = 1./(t.*exp_pos);

    A(1,1,:) = invtp;
    A(1,2,:) = invtm.*r;
    A(2,1,:) = invtp.*r;
    A(2,2,:) = invtm;

   
   B    = eye(2,2);

   for j = length(rho_e):-1:2
     B    = A(:,:,j)*B;
   end

   Binv = eye(2,2);

   for j = 2:1:length(rho_e)
     Binv = Binv*A(:,:,j);
   end


   Mcell     = B*Mcell;
   Mcell_inv = Binv*Mcell_inv;
end


function A = make_A_matrix(Q,lambda,rho_e,dz)
    % Constants
    re = 2.814042735053330e-05;
    k0 = (2*pi/lambda);
    factor      = 8 * k0^2 * lambda^2 / (2 * pi);
    
    % Precompute layer properties
    sld   = rho_e * re / (2 * pi ); 
    delta = factor * real(sld);
    beta  = 1i*factor * imag(sld);
    A = zeros(2,2,length(rho_e),length(Q));

    % Compute kz and kz of adjacent layers
    for i = 1:length(Q)
      kz_all     = sqrt(Q(i).^2 - delta + beta);  % Vectorized kz
      kz_shifted = circshift(kz_all, 1);     % Shifted kz for previous layer


      denom = 1./(kz_shifted + kz_all);
      r     = (kz_shifted-kz_all).*denom;
      t     = 2*kz_shifted.*denom;

      exp_pos  = exp(1i * kz_all * dz / 2);

      invtp     = exp_pos./t;
      invtm     = 1./(t.*exp_pos);

      A(1,1,:,i) = invtp;
      A(1,2,:,i) = invtm.*r;
      A(2,1,:,i) = invtp.*r;
      A(2,2,:,i) = invtm;

    end
end

function B = do_matrix_propagation_optimzed_vec(A) %,z)

  [m,n,o,l] = size(A);
  
   B         = zeros(2,2,l);
   B(1,1,:)  = 1;
   B(2,2,:)  = 1;
   A_sum_d   = reshape(A(1,1,:,:) + A(2,2,:,:),[o,l]);   % (a + d)
   C_sum_d   = reshape(A(2,1,:,:) + A(2,2,:,:),[o,l]);   % (c + d)
   A_sum_b   = reshape(A(1,1,:,:) + A(1,2,:,:),[o,l]);   % (a + b)
   B_minus_d = reshape(A(1,2,:,:) - A(2,2,:,:),[o,l]);   % (b - d)
   C_minus_a = reshape(A(2,1,:,:) - A(1,1,:,:),[o,l]);   % (c - a)
   

   for j = o:-1:2
    B_sum_h   = reshape(B(1,1,:) + B(2,2,:),[1,l]);   % (e + h)
    F_minus_h = reshape(B(1,2,:) - B(2,2,:),[1,l]); % (f - h)
    G_minus_e = reshape(B(2,1,:) - B(1,1,:),[1,l]); % (g - e)
    B_sum_f   = reshape(B(1,1,:) + B(1,2,:),[1,l]);   % (e + f)
    B_sum_g   = reshape(B(2,1,:) + B(2,2,:),[1,l]);   % (g + h)
    
    M1 = A_sum_d(j,:) .* B_sum_h;      % M1 = (a + d)(e + h)
    M2 = C_sum_d(j,:) .* reshape(B(1,1,:),[1,l]);       % M2 = (c + d)e
    M3 = reshape(A(1,1,j,:),[1,l]) .* F_minus_h;     % M3 = a(f - h)
    M4 = reshape(A(2,2,j,:),[1,l]) .* G_minus_e;     % M4 = d(g - e)
    M5 = reshape(A_sum_b(j,:),[1,l]) .* reshape(B(2,2,:),[1,l]);       % M5 = (a + b)h
    M6 = C_minus_a(j,:) .* B_sum_f;    % M6 = (c - a)(e + f)
    M7 = B_minus_d(j,:) .* B_sum_g;    % M7 = (b - d)(g + h)
    
    B(1,1,:) = M1 + M4 - M5 + M7;
    B(1,2,:) = M3 + M5;
    B(2,1,:) = M2 + M4;
    B(2,2,:) = M1 - M2 + M3 + M6;
   end

end

function B = do_matrix_propagation_optimzed_vec_linear(A) %,z)

  [~,~,o] = size(A);
  
   B         = eye(2,2);
 
   A_sum_d   = A(1,1,:) + A(2,2,:);   % (a + d)
   C_sum_d   = A(2,1,:) + A(2,2,:);   % (c + d)
   A_sum_b   = A(1,1,:) + A(1,2,:);   % (a + b)
   B_minus_d = A(1,2,:) - A(2,2,:);   % (b - d)
   C_minus_a = A(2,1,:) - A(1,1,:);   % (c - a)
   

   for j = o:-1:2
    B_sum_h   = B(1,1) + B(2,2);   % (e + h)
    F_minus_h = B(1,2) - B(2,2); % (f - h)
    G_minus_e = B(2,1) - B(1,1); % (g - e)
    B_sum_f   = B(1,1) + B(1,2);   % (e + f)
    B_sum_g   = B(2,1) + B(2,2);   % (g + h)
    
    M1 = A_sum_d(j) .* B_sum_h;      % M1 = (a + d)(e + h)
    M2 = C_sum_d(j) .* B(1,1);       % M2 = (c + d)e
    M3 = A(1,1,j) .* F_minus_h;     % M3 = a(f - h)
    M4 = A(2,2,j).* G_minus_e;     % M4 = d(g - e)
    M5 = A_sum_b(j).*B(2,2);       % M5 = (a + b)h
    M6 = C_minus_a(j) .* B_sum_f;    % M6 = (c - a)(e + f)
    M7 = B_minus_d(j) .* B_sum_g;    % M7 = (b - d)(g + h)
    
    B(1,1) = M1 + M4 - M5 + M7;
    B(1,2) = M3 + M5;
    B(2,1) = M2 + M4;
    B(2,2) = M1 - M2 + M3 + M6;
   end

end